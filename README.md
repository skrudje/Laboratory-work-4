Лабораторная работа №4: Многопоточность
Цель работы
Изучение принципов реализации многопоточности и практическое применение возможностей языков высокого уровня при моделировании бизнес-процессов.

Задания
Задание 1: Примитивы синхронизации
Реализовать параллельный запуск заданного числа потоков, генерирующих случайные символы из ASCII-таблицы в формате гонки.
Проанализировать особенности работы следующих примитивов синхронизации:

1.a. Mutexes
1.b. Semaphore
1.c. Barrier
1.d. SpinLock
1.e. SpinWait
1.f. Monitor
Для каждого примитива выполнен сравнительный анализ производительности с использованием точных замеров времени выполнения (std::chrono).

Задание 2: Многопоточная обработка данных
Реализована обработка массива структур «Студент» с полями:

ФИО
курс
количество задолженностей
Условие отчисления: количество задолженностей > Z и курс > K, где из условия задания:

Z = 2
K = 0
Программа выводит:

время обработки без многопоточности,
время обработки с многопоточностью,
список ФИО студентов, подлежащих отчислению.
Поддерживается ручной ввод:

размера массива (общего количества студентов),
количества потоков,
значения порога K (курс).
Задание 3: Обедающие философы Дейкстры
Реализована классическая задача «Обедающие философы» в соответствии с методикой, описанной по ссылке:
http://www.softcraft.ru/auto/ka/fil/

Решение гарантирует отсутствие взаимоблокировок (deadlock) за счёт ограничения числа одновременно сидящих за столом философов.
Программа визуализирует процесс: для каждого из 5 философов выводятся состояния «думает» и «ест» с разделением на раунды.

Технические детали
Язык реализации: C++17
Компилятор: g++ с флагами -std=c++17 -O2 -pthread
Сборка проекта: через Makefile
Все три задания реализованы как независимые программы с многофайловым проектом (.h, .cpp, main.cpp, Makefile)
